##  2-1

### (a)

根据题目我们知道长度为n的数组被分成n/k个长度为k的子数组，那么插入排序的的运行时间就应该为(n/k)T(k),根据已知插入排序的运行时间为T(n)=(c<sub>5</sub>/2+c<sub>6</sub>/2+c<sub>7</sub>/2)n<sup>2</sup>+(c<sub>1</sub>+c<sub>2</sub>+c<sub>4</sub>+c<sub>5</sub>/2-c<sub>6</sub>/2-c<sub>7</sub>/2+c<sub>8</sub>)n-(c<sub>2</sub>+c<sub>4</sub>+c<sub>5</sub>+c<sub>8</sub>),那么(n/k)T(k)=(n/k)[(c<sub>5</sub>/2+c<sub>6</sub>/2+c<sub>7</sub>/2)k<sup>2</sup>+(c<sub>1</sub>+c<sub>2</sub>+c<sub>4</sub>+c<sub>5</sub>/2-c<sub>6</sub>/2-c<sub>7</sub>/2+c<sub>8</sub>)k-(c<sub>2</sub>+c<sub>4</sub>+c<sub>5</sub>+c<sub>8</sub>)],去增长速度最高的项，时间复杂度为O(nk)。<br/>

### (b)

当n=k时，T(n)=0<br/>
当n>k时，T(n)=2T(n/2)+cn<br/>
因为叶节点不对数据进行处理，而是直接把数据交给插入排序，所以最底层时间复杂度为0。到达叶节点时，长度为n的数组被分为了n/k个长度为k的子数组，根据书上的公式，此时递归树应有lg(n/k)+1层，除了最底层外，每层的代价都为cn，所以总代价就为cn(lg(n/k)),忽略常数项就为**n(lgn)**。<br/>

### (c)

当k=lgn时,O(nlgn+nlg(n/lgn))，由于第二项的增长速度远小于第一项，所以忽略第二项，可以得到O(nlgn)。
当k>lgn时此式大于O(nlgn)。

### (d)

**代码在同目录下main.go中给出**<br/>
测试方法为每次输入固定长度的数组，数组元素每次都随机生成，调整k的大小，看k对运行时间的影响，为了保证结果不具备偶然性，共测六次。<br/>
(1)数组长度为1千,k的值为10<br/>

|      |   1   |   2  |   3   |   4   |   5   |   6   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|MixSort|   0s   |   0s   |    0s  |    0s  |    0s  |  0s    |
|MergeSort|   0s  |   0s   |   0s   |    0s  |   0s   |   0s   |

由于数据量过小，所以两个排序消耗时间都基本为0，程序计时器无法探测到耗时。<br/>

(2)数组长度为1万，k的值为10<br/>

|      |   1   |   2  |   3   |   4   |   5   |   6   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|MixSort|   990.1µs   |   998.9µs   |    987.2µs  |    999.4µs  |    1.9981ms  |  999.4µs   |
|MergeSort|   1.9993ms   |   999.7µs   |   2.0105ms   |    1.9984ms  |   1.0006ms   |   999.2µs   |

可见此时，混合排序此时对归并排序具有一定的优势。<br/>

(3)数组长度为1万，k的值为15<br/>

|      |   1   |   2  |   3   |   4   |   5   |   6   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|MixSort|   999.5µs   |   999.4µs   |    999.4µs  |    999.3µs  |    999.2µs  |  1.003ms    |
|MergeSort|   998.6µs   |   1.9992ms   |   999.1µs   |    1.9984ms  |   1.999ms   |   998.4µs   |

可见此时，混合排序此时对归并排序具有一定的优势。<br/>

(4)数组长度为1万，k的值为20<br/>

|      |   1   |   2  |   3   |   4   |   5   |   6   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|MixSort|   999.5µs   |   999.5µs   |    999.5µs  |    999.7µs  |    999.2µs  |  999.5µs    |
|MergeSort|   999.1µs   |   998.7µs   |   1.9987ms   |    999.1µs  |   999.6µs   |   999.4µs   |

可见此时，混合排序此时对归并排序基本属于同一水平。<br/>

(5)数组长度为1万，k的值为30<br/>

|      |   1   |   2  |   3   |   4   |   5   |   6   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|MixSort|   987.3µs   |   999.7µs   |   999.1µs  |    1.0078ms  |    997.5µs  |  986.7µs    |
|MergeSort|   998.1µs   |   1.9983ms   |   999.6µs  |    1.9897ms  |   1.9991ms   |   999.1µs   |

可见此时，混合排序此时对归并排序具有一定的优势。<br/>

(6)数组长度为1万，k的值为50<br/>

|      |   1   |   2  |   3   |   4   |   5   |   6   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|MixSort|   999.6µs   |   999.8µs   |   999.4µs  |    998.3µs  |    1.0026ms  |  999.5µs    |
|MergeSort|   1.9989ms   |   1.999ms   |   999.8µs  |    2.0123ms  |   1.996ms   |   999.5µs   |

可见此时，混合排序此时对归并排序具有一定的优势。<br/>

(7)数组长度为1万，k的值为100<br/>

|      |   1   |   2  |   3   |   4   |   5   |   6   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|MixSort|   0s   |   999.3µs   |   2.0119ms  |    999.7µs  |    999.4µs  |  1.0001ms   |
|MergeSort|   1.9997ms   |   1.9989ms   |   4.9975ms  |    999.3µs  |   999.7µs   |   999µs   |

可见此时，混合排序此时对归并排序具有一定的优势。<br/>

(8)数组长度为1万，k的值为500<br/>

|      |   1   |   2  |   3   |   4   |   5   |   6   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|MixSort|   998.9µs   |   1.001ms   |   1.0011ms  |    1.0003ms  |    2.011ms |  986.9µs  |
|MergeSort|   999.1µs   |   1.0069ms   |   997.5µs  |    2.0111ms  |   2.0017ms   |   1.0005ms   |

可见此时，混合排序和归并排序性能基本一致。<br/>

(9)数组长度为1万，k的值为700<br/>

|      |   1   |   2  |   3   |   4   |   5   |   6   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|MixSort|  1.9988ms   |   1.9989ms   |   1.9985ms  |    1.9991ms  |    999µs |  999.6µs  |
|MergeSort|   999.4µs   |   999.4µs   |   1.0003ms  |    999.4µs  |   1.9989ms   |   999.8µs   |

可见此时，归并排序对混合排序已经实现了反超。<br/>

(10)数组长度为10万，k的值为500<br/>

|      |   1   |   2  |   3   |   4   |   5   |   6   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|MixSort|  15.9816ms   |   14.992ms   |   14.9924ms  |   14.9936ms  |    14.9912ms |  15.9916ms  |
|MergeSort|   10.0069ms   |   11.9952ms   |   10.9849ms  |    9.9187ms  |   15.9946ms   |   12.9926ms   |

可见此时，归并排序性能更强。<br/>

(11)数组长度为10万，k的值为100<br/>

|      |   1   |   2  |   3   |   4   |   5   |   6   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|MixSort|  11.9929ms   |   11.9844ms   |   11.9937ms  |   11.9954ms  |    10.9926ms|  12.0067ms  |
|MergeSort|   11.0818ms  |   11.0061ms   |   12.9927ms  |    11.0043ms  |   10.996ms  |   10.981ms   |

可见此时，归并排序性能更强，但强度有限。<br/>

(12)数组长度为10万，k的值为50<br/>

|      |   1   |   2  |   3   |   4   |   5   |   6   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|MixSort|  11.9944ms   |   11.0063ms   |   10.9847ms  |   10.9922ms  |    17.9773ms|  13.0025ms  |
|MergeSort|   12.0052ms  |   10.9822ms   |   10.9894ms  |    11.0044ms  |   16.9881ms  |   9.9845ms   |

可见此时，归并排序性能更强，但强度有限。<br/>

(13)数组长度为10万，k的值为20<br/>

|      |   1   |   2  |   3   |   4   |   5   |   6   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|MixSort|  12.9926ms   |   13.9798ms   |   12.9929ms  |   12.0059ms |    12.0055ms|  12.9922ms  |
|MergeSort|   12.9923ms  |   11.9953ms   |   12.0066ms  |   11.9941ms |   10.9828ms  |  10.9959ms   |

可见此时，归并排序性能更强，但强度有限，而且对比MixSort前几组数据，推测此时k已到达最小值，继续减小k的值只会增加运行时间。且对比数组长度为1万时，此时最优的MixSort和归并排序并没有什么什么太大的性能差距，推测在数组长度继续增加只会增加MixSort的运行时间。<br/>

(14)数组长度为100万，k的值为100<br/>

|      |   1   |   2  |   3   |   4   |   5   |   6   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|MixSort|  133.9337ms   |   138.9226ms   |   155.9131ms  |   133.9323ms  |    154.9101ms|  135.9224ms  |
|MergeSort|   127.9176ms  |   135.9215ms   |   131.1484ms  |    126.9334ms  |   127.9272ms  |   129.9475ms   |

可见此时，归并排序性能更强。由前几组数据推测，当数组足够大时，影响MixSort的主要因素是子数组的大小，且此时插入排序已经对运行时间起不到优化作用。实验结果符合两个排序算法的时间复杂度。<br/>

**综上所诉，在go语言中，k的值选择100左右最为合适，且此时数据量小于5万**

## 2-2

### (a)

回想一下循环不变式的终止，终止时应符合排序后的数组应该和原数组是同一个数组，也就是要保证数据的一致性。<br/>

### (b)

**初始化**：初始时，不包含任何元素。A[ j ]应该是子数组A[ j..n]中的最小元素。<br/>
**保持**：每次比较A[ j-1 ]和A[ j ]的大小，如果A[ j ]<A[ j-1 ] 则交换两个元素的位置 ，接下来由于for循环进入下一次迭代。因此，在下一次开始时，j的值将减1，A[ j ]仍未A[ j..n] 中的最小元素。<br/>
**终止**：导致for循环终止的条件是j<i+1,因为每次循环 j 减少1，那么必有j = i，在循环不变式中用 i 替换 j ，我们有：子数组A[ i..n ]由原来在A[ i..n ]中的元素组成，且A[ i ]为子数组A[ i..n]中的最小元素。<br/>

### (c)

**初始化**：子数组A[1.. i ]为已排序数组，初始时，不包含任何元素。<br/>
**保持**： 第2-4行，每次A[i ]都为A[i..n ]中最小的一个元素。<br/>
**终止**：导致for循环终止的条件是i>A.length-1,因此必有i=A.length=n,在循环不变式中用n替换 i ，我们有A[ 1..n ]由原来在A[ 1..n ]中元素组成，但已按从小到大排序。<br/>

### (d)

虽然两个算法在时间复杂度上都是O(n²)，但是冒泡排序在交换元素时涉及到了三个变量，而插入排序则是每次交换两个变量，最后再处理当前值的交换，所以冒泡排序在这一步的操作是3[n(n-1)/2],而插入排序则是2[(n(n-1)/2]+1,所以插入排序要比冒泡排序性能更优。

## 2-3

### (a)

```
y = 0
for i = n downto 0
    y = aᵢ + x·y
```
显然时间复杂度为O(n)。<br/>

### (b)

```
y = 0
for i = 0 to n
	power = 1
	for j = 1 to i
		power=power·x
	y=y+aᵢ·power
```
显然这个算法的时间复杂度为O(n²)，远远比不上霍纳规则。<br/>

### (c)

**初始化**：开始时，y=0
**保持**：
**终止**：









