## 2.2-1
这题没什么好说的,增长度最大的项为n^3<br/>
时间复杂度：O(n^3)<br/>
## 2.2-2
求和公式有点复杂，我会在后续的版本更新<br/>
```
//到n-1是因为既然前n-1个元素都是每个子数组A[i..n]中最小的元素，那么当循环到最后一个元素时，必然为A[n-1..n]中的最小元素
for i = 1 to A.length-1                //c1  n
    min = i                            //c2  n-1
    for j = i + 1 to A.length          //c3  2+..+n
        if A[i] < min                  //c4  2+..+n-1
            min = j                    //c5  2+..+n-1
    if min ≠ i                         //c6 n-1
        exchange A[i] with A[min]      //c7 n-1
```
**循环不变式**<br/>
初始化：开始时，循环不变式中不包含任何一个元素。<br/>
保持：因为每次都选择A[i..n]中最小的元素加入A[1..i-1]中,所以A[1..i-1]中一直为一个从小到大排列的数组，比A[i]小的在A[1..i-1]中，比A[i]大的在A[i+1..n]中。<br/>
终止：当循环到最后一个元素时，程序终止，此时整个数组都已被排序，循环不变式仍成立。<br/>
**时间复杂度**<br/>
最优：最优当然是整个数组都被正排序，然而，这并没有什么用，因为第二个for循环不管当前元素是否为子数组A[i..n]中的最小元素都会遍历整个子数组，直到它遍历完真个子数组，确定当前元素为子数组中的最小元素，但两个if中的赋值语句都不会执行。<br/>
c<sub>1</sub>n+c<sub>2</sub>(n-1)+c<sub>3</sub>[n(n+1)/2 - 1]+c<sub>4</sub>[n(n-1)/2]+c<sub>6</sub>(n-1)<br/>
=(c<sub>3</sub>/2+c<sub>4</sub>/2)n<sup>2</sup>+(c<sub>1</sub>+c<sub>2</sub>+c<sub>6</sub>-c<sub>4</sub>/2)n-(c<sub>2</sub>+c<sub>3</sub>+c<sub>6</sub>)<br/>
最差：最差的情况是整个数组都被逆序排列，那么这个程序中的每一个语句都会被执行。<br/>
c<sub>1</sub>n+c<sub>2</sub>(n-1)+c<sub>3</sub>[n(n+1)/2 - 1]+c<sub>4</sub>[n(n-1)/2]+c<sub>5</sub>[n(n-1)/2]+c<sub>6</sub>(n-1)+c<sub>7</sub>(n-1)<br/>
=(c<sub>3</sub>/2+c<sub>4</sub>/2+c<sub>5</sub>/2)n<sup>2</sup>+(c<sub>1</sub>+c<sub>2</sub>+c<sub>6</sub>-c<sub>4</sub>/2-c<sub>5</sub>/2)n-(c<sub>2</sub>+c<sub>3</sub>+c<sub>6</sub>+c<sub>7</sub>)<br/>
无论是最优还是最差时间复杂度都为O(n<sup>2</sup>)
## 2.2-3
**时间复杂度**<br/>
平均：O(n)<br/>
平均要搜索n/2个元素，也就是一半元素大于v，一半元素小于v<br/>
最坏: O(n)<br/>
遍了了整个数组都没有找到和v相等的元素<br/>

## 2.2-4
这题是一道没有标准答案的题<br/>
我个人的见解是，输入的内容是符合输出条件的。<br/>

